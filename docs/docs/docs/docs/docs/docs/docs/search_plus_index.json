{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-19 10:14:12 "},"2week/4_19/":{"url":"2week/4_19/","title":"4.19","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 junit的Assert 2 Java 开发的模拟测试框架: Mockito 2.1 验证行为 2.2 Stub（存根/打桩） 2.3 参数匹配器 2.4 调用次数 2.5 简化Mock创建方式(注解) 2.6 间接依赖bean 2.7 @spy神器 2.8 api 3 nio的Path,File 3.1 路径 3.2 api 3.3 NIO和IO遍历指定目录效果对比 第2周-4.19 1 junit的Assert 2022-4-19 11:50:4 assert: 断言 junit断言总结 平时编写自己的测试类，如果没有断言，那么就没写测试的必要了。 JUnit框架用一组assert方法封装了最常见的测试任务。 junit中的assert方法全部放在Assert类中，都是静态方法。（因此可以静态引用） 方法 解释 assertTrue/False([String message,]boolean condition); 判断一个条件是true还是false fail([String message,]); 失败，可以有消息，也可以没有消息。 assertEquals([String message,]Object expected,Object actual); 判断是否相等，可以指定输出错误信息。第一个参数是期望值，第二个参数是实际的值。 assertNotNull/Null([String message,]Object obj); 判读一个对象是否非空(非空)。 assertSame/NotSame([String message,]Object expected,Object actual); 判断两个对象是否指向同一个对象。看内存地址。 failNotSame/failNotEquals(String message, Object expected, Object actual) 当不指向同一个内存地址或者不相等的时候，输出错误信息。 说白了，就是先提前断言（判断）想要得到的结果，如果与预想的不一致，Assert类就会抛出一个AssertionFailedError异常，Junit测试框架将这种错误归入Fails并且加以记录。 2 Java 开发的模拟测试框架: Mockito 2022-4-19 11:50:11 https://baijiahao.baidu.com/s?id=1727997644914260506&wfr=spider&for=pc https://blog.csdn.net/xiao__jia__jia/article/details/115252780 解决： 如何测试一个rest接口； 如何测试一个包含客户端调用服务端的复杂方法； 如何测试一个包含从数据库读取数据的复杂方法; ... 假设现在要测试method A, method A里面又依赖Method B、Method C、Method D，而依赖的这3个method又不好去构建（如ObsClient需要真实AK SK，HttpClient需要构建客户端与服务器，Database相对好构建，但是假设Method C只是从table1、table2联合查询，你还得分别往table1、table2 insert数据，很繁琐），这时候可以考虑Mockito进行优雅测试，当然如果你想去构建真实的测试场景，未免有点舍本逐末了 说白了，就是构造一些虚拟数据，来测试方法，避免大动干戈。 使用（可以静态引用）： 2.1 验证行为 一旦mock对象被创建了，mock对象会记住所有的交互。然后你就可以选择性的验证你感兴趣的交互，也就是说，你对这个Mock对象做的操作，都被记录下来了，验证的时候会是合法的。 @Test void testBehavior() { //构建moock数据 List list = mock(List.class); list.add(\"1\"); list.add(\"2\"); System.out.println(list.get(0)); // 会得到null ，前面只是在记录行为而已，没有往list中添加数据 verify(list).add(\"1\"); // 正确，因为该行为被记住了 verify(list).add(\"3\");//报错，因为前面没有记录这个行为 } 2.2 Stub（存根/打桩） 存根：用于预先说明当执行了什么操作的时候，产生一个什么响应， 存根特点：默认情况下，所有的函数都有返回值。 mock函数默认返回的是： null， 一个空的集合或者 一个被对象类型包装的内置类型，例如0、false对应的对象类型为Integer、Boolean； 测试桩函数可以被覆写 : 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；一旦测试桩函数被调用，该函数将会一致返回固定的值； 示例：常规存根，主要用到when 、thenReturn、then、thenThrow、thenAnswer这几个函数。 @Test void testStub() { List l = mock(ArrayList.class); when(l.get(0)).thenReturn(10); when(l.get(1)).thenReturn(20); when(l.get(2)).thenThrow(new RuntimeException(\"no such element\")); assertEquals(l.get(0), 10); assertEquals(l.get(1), 20); assertNull(l.get(4)); assertThrows(RuntimeException.class, () -> { int x = l.get(2); }); } void函数存根 主要用到doThrow(), doAnswer(), doNothing(), doReturn() and doCallRealMethod()等函数，当然，这些函数也可以用于有返回值的函数的存根； 需要注意的是，doCallRealMethod不能用于Mock对象，只能用于监察对象。 @Test void testVoidStub(){ List l = mock(ArrayList.class); doReturn(10).when(l).get(1); doThrow(new RuntimeException(\"you cant clear this List\")).when(l).clear(); assertEquals(l.get(1),10); assertThrows(RuntimeException.class,()->l.clear()); } 2.3 参数匹配器 在上面的stub测试中，我们需要对我们关系的数据一个一个的进行stub，如果数据过多的时候，会比较麻烦， 这个时候，我们可以利用参数匹配器来完成相应的操作，参数既可以用与stub，也可以用于验证的时候。 所有的参数匹配器都存放在org.mockito.ArgumentMatchers中。 @Test void testMatchers() { List l = mock(ArrayList.class); when(l.get(anyInt())).thenReturn(100); assertEquals(l.get(999),100); } 2.4 调用次数 校验某个操作执行的次数 @Test void testTimes() { List l = mock(ArrayList.class); when(l.get(anyInt())).thenReturn(100); System.out.println(l.get(0)); System.out.println(l.get(1)); System.out.println(l.get(1)); System.out.println(l.get(2)); System.out.println(l.get(2)); System.out.println(l.get(2)); System.out.println(l.get(2)); verify(l, times(7)).get(anyInt()); verify(l, atLeastOnce()).get(0); verify(l, atLeast(3)).get(2); verify(l, atMost(6)).get(2); verify(l, atMostOnce()).get(0); } 2.5 简化Mock创建方式(注解) 可以通过@Mock注解来简化Mock对象的创建过程，这样的话，我们就可以在多个测试中直接共用这些mock对象了， 需要注意的是，我们需要在方法开始执行下面的操作：MockitoAnnotations.initMocks @Mock private MyService myService; //会将MyService进行Mock @InjectMocks private MyController MyController; // 会向MyController注入Mock对象, 例如：myService @Before public void init() { MockitoAnnotations.initMocks(this); } 2.6 间接依赖bean 如果一个Bean A依赖于Bean B，而Bean B又依赖于Bean C，现在想对A的接口进行测试，又想把C Mock掉。 例如：MyFirstService 间接依赖了MyService, 下面演示如何将MyService进行隔离。 使用mock生成一个虚拟的对象，这样不需要在spring-test.xml文件单独配置这个myservice的Bean。 @Profile(\"development\") @Configuration public class MyServiceTestConfiguration { @Bean(name = \"myService\") @Primary // spring在寻找时，优先使用该bean public MyService myService() { return Mockito.mock(MyService.class); } } 测试: @ContextConfiguration(\"classpath:spring-test.xml\") @RunWith(SpringJUnit4ClassRunner.class) @ActiveProfiles(\"development\") public class myServiceImplTest { @Autowired private myFirstService myFirstService; } 2.7 @spy神器 spy类的原理是，如果不打桩默认都会执行真实的方法，如果打桩则返回桩实现。 对 spy 变量打桩时，如果使用 when 去设置模拟值时，他里面的代码逻辑依然会被执行，只是mock了返回结果； 使用 doReturn 设置模拟值的话，则不会出现这个问题！ A aSpy = spy(new A()); //aSpy.set...(); when(aSpy.service()).thenReturn(\"spy!\");//service()逻辑依然执行 doReturn(\"spy!\").when(aSpy).service();//service()不会执行 注意：spy后的实例，原有处理逻辑还在，但内部对象还得靠自己手动set进去 两个方法同个方法名，参数类型分别为Object 和 Collection， anyObject（）无法区分Object 和Collection，会导致程序走真实逻辑。 可以这样处理： anyCollection() 匹配Collection 和 any(MyClass.class) 2.8 api （一）Mockito org.mockito.Mockito是mockito提供的核心api，提供了大量的静态方法，用于帮助我们来mock对象，验证行为等等，然后需要注意的是，很多方法都被封装在了MockitoCore类里面，下面对一些常用的方法做一些介绍。 方法 解释 mock 构建一个我们需要的对象；可以mock具体的对象，也可以mock接口。 spy 构建监控对象 verify 验证某种行为 when 当执行什么操作的时候，一般配合thenXXX 一起使用。表示执行了一个操作之后产生什么效果。 doReturn 返回什么结果 doThrow 抛出一个指定异常 doAnswer 做一个什么相应，需要我们自定义Answer； times 某个操作执行了多少次 atLeastOnce 某个操作至少执行一次 atLeast 某个操作至少执行指定次数 atMost 某个操作至多执行指定次数 atMostOnce 某个操作至多执行一次 doNothing 不做任何处理 doReturn 返回一个结果 doThrow 抛出一个指定异常 doAnswer 指定一个操作，传入Answer doCallRealMethod 返回真实业务执行的结果，只能用于监控对象 （二）ArgumentMatchers 用于进行参数匹配，减少很多不必要的代码 方法 解释 anyInt 任何int类型的参数，类似的还有anyLong/anyByte等等。 eq 等于某个值的时候，如果是对象类型的，则看toString方法 isA 匹配某种类型 matches 使用正则表达式进行匹配 （三）OngoingStubbing OngoingStubbing用于返回操作的结果。 方法 解释 thenReturn 指定一个返回的值 thenThrow 抛出一个指定异常 then 指定一个操作，需要传入自定义Answer； thenCallRealMethod 返回真实业务执行的结果，只能用于监控对象。 3 nio的Path,File 2022-4-19 15:1:24 java7提供 在很多方面，java.nio.file.Path接口和java.io.File有相似性，但也有一些细微的差别。在很多情况下，可以用Path来代替File类。 3.1 路径 windows下绝对路径 Path path = Paths.get(\"c:\\\\data\\\\myfile.txt\"); //1 Path path = Paths.get(\"/home/jakobjenkov/myfile.txt\");//2. 会被解析成相对路径：base为C盘，从而对应绝对路径是：C:/home/jakobjenkov/myfile.txt linux下绝对路径 Path path = Paths.get(\"/home/jakobjenkov/myfile.txt\"); 3.2 api Paths 方法 解释 Path get(String,...) 获得Path对象 Path 方法 解释 String toString() 返回调用 Path 对象的字符串表示形式 boolean starts With(String path) 判断是否以 path 路径开始 boolean ends With(String path) 判断是否以 path 路径结朿 boolean isAbsolute() 判断是否是绝对路径 Path getParento 返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 Path getRoot() 返回调用 Path 对象的根路径 Path getFileName 返回与调用 Path 对象关联的文件名 int getNameCount() 返回Path 根目录后面元素的数量 Path getName (int idx) 返回指定索引位置idx 的路径名称 Path toAbsolute Path() 作为绝对路径返回调用 Path 对象 Path resolve(Path p) 合并两个路径，返回合并后的路径对应的Path对象 File toFile() 将Path转化为File类的对象 Files 用于操作文件或目录 方法 解释 Path copy(Path sc, Path dest, CopyOption ...how) 文件的复制 Path createDirectory(Path path, FileAttribute ...attr) 创建一个自录 Path createFile(Path path, FileAttribute ...arr) 创建一个文件 void delete (Path path) 删除一个文件/目录，如果不存在，执行报错 void deletelfExists (Path path) Path对应的文件/目录如果存在，执行删除 Path move(Path src. Path dest. CopyOption...how) 将src移动到dest 位置 long size(Path path) 返回 path 指定文件的大小 用于判断 方法 解释 boolean exists(Path path, LinkOption opts) 判断文件是否存在 boolean isDirectory(Path path, LinkOption opts) 判断是否是目录 boolean isRegularFile(Path path. LinkOption...opts) 判断是否是文件 boolean isHidden(Path path) 判断是否是隐薇文件 boolean isReadable(Path path) 判断文件是否可读 boolean isWritable(Path path) 判断文件是否可写 boolean notExists(Path path. LinkOptionu opts) 判断文件是否不存在 用于操作内容 方法 解释 SeekableByteChannel newByte Channel(Path path OpenOption...how) 获取与指定文件的连接，how 指定打开方式。 DirectoryStream newDirectoryStream(Path path) 打开path指定的目录 InputStream newlnputStream(Path path. OpenOption ... how) 获取InputStream对象 OutputStream newOutputStream(Path path, OpenOption ... how) 获取OutputStream对象 3.3 NIO和IO遍历指定目录效果对比 利用IO的File递归遍历目录： public static void showPath(String dir){ File files = new File(dir); if (files.isDirectory()) { for (File file: files.listFiles() ) { System.out.println(file.getAbsolutePath()); showPath(file.getAbsolutePath().toString()); } }else{ return; } } 采用NIO的Files.walk方法，借助Stream流 直接逐一把目录打印出来： public static void printDir(String dir){ Path path = Paths.get(dir); try { Files.walk(path).forEach(System.out::println); } catch (IOException e) { e.printStackTrace(); } } 汽车为你造好了，没必要再骑车上高速了。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-20 09:59:34 "},"2week/4_20/":{"url":"2week/4_20/","title":"4.20","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 maven 1.1 生命周期 1.2 maven寻找依赖流程 1.3 idea里的maven wrapper 第2周-4.20 1 maven 2022-4-20 9:57:7 1.1 生命周期 1 compile mvn compile会在当前目录生成target目录。 2 clean mvn clean删除当前目录中的target目录。 3 package mvn package将本地工程打包成jar包。 4 install mvn install将本地工程打包成jar包，放入到本地仓库中。 之后，其它Maven管理的项目可以通过pom.xml配置依赖引入到其工程。 其它 mvn -DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。 mvn -Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。 1.2 maven寻找依赖流程 Maven 将从本地资源库获得 Maven 的本地资源库依赖资源(默认用户目录下的.m2目录)，如果没有找到， 它会从默认的 Maven 中央存储库 – http://repo1.maven.org/maven2/ 查找下载，如果还是没有找到， 它会从配置的远程存储库（包括私服、JBOSS仓库和java.net仓库）查找下载。 1.3 idea里的maven wrapper 要使用maven wrapper有2种方式： 1、 主动生成： mvn -N io.takari:maven:0.7.6:wrapper 会生成3个文件： mvnw(linux命令) mvnw.cmd(windows命令) .mvn目录 2、从别的项目中将这3个文件copy过来 有了这3个文件后， maven的具体版本只依赖于当前项目中(.mvn/wrapper/maven-wrapper.properties)所配置的maven版本。 在项目目录下，使用mvnw代替以前的mvn命令。 mvnw会在每次执行命令时检测${home}/.m2/wrapper/dists目录下是否有maven-wrapper.properties中指定Maven版本，如果没有就将maven环境自动下载到dists目录。 maven的配置文件settings.xml必须在{user}/.m2目录下 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-20 13:40:43 "},"2week/4_22/":{"url":"2week/4_22/","title":"4.22","keywords":"","body":"第2周-4.22 1 idea的git标签中的符号含义 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-22 15:03:58 "},"3week/4_27/":{"url":"3week/4_27/","title":"4.27","keywords":"","body":"第3周-4.27 1 linux -- less less is more. less [-options] []表示可选，<>表示必选 options desc -b 《缓冲区大小》 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o 《文件名》 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x 《数字》 将“tab”键显示为规定的数字空格 常用命令：less -mN 在查看期间，可通过以下命令来操作阅读文件： 当往下看浏览的时候，后代表下，前代表上； 当往上看浏览的时候，后代表上，前代表下。 operation desc /str 向后搜索“str”的功能 ?str 向前搜索“str”的功能 n 重复前一个搜索(与 / 或 ? 有关) N 反向重复前一个搜索(与 / 或 ? 有关) b 向前翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 g 跳到文件头 【常用】 G 跳到文件尾部 【常用】 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-28 10:35:03 "},"4week/5_3/":{"url":"4week/5_3/","title":"5.3","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 java里执行第三方脚本 1.1 Process.exitValue() 1.2 Process.waitFor() 2 idea等ide的build区别 3 ExecutorService API 第4周-5.3 1 java里执行第三方脚本 When Runtime.exec() won't 简析 Runtime.exec(..) java 程序中，如果我们想执行一些 Shell 命令或其他外部应用程序，通常都是使用java.lang.Runtime.exec(..)方法来执行的。 当 Java 内置的 Runtime.exec(..) 方法在执行外部命令时，可能存在一些不易察觉的坑，往往会导致程序运行失败。 1.1 Process.exitValue() IllegalThreadStateException异常：Runtime.exe(..)可能出现IllegalThreadStateException异常。我们通常使用exec(..)方法执行 JVM 外部程序，如果想查看外部程序返回值，可以使用Process.exitValue()方法。 需要注意的是，如果直接使用Process.exitValue()获取外部程序返回值，如果此时外部程序还未运行完成，则会抛出IllegalThreadStateException异常。 举个栗子：比如在 Java 中执行 javac 程序，并获取其返回值。 代码如下： public class BadExecJavac { public static void main(String[] args) throws IOException { Process pid = Runtime.getRuntime().exec(\"javac\"); int exitValue = pid.exitValue(); System.out.println(\"Process exitValue: \" + exitVal); } } 使用Process.waitFor()替换Process.exitValue()。 1.2 Process.waitFor() Process.waitFor()与Process.exitValue()同样会返回外部程序的执行结果，但是它会阻塞直到外部程序运行结束。 代码如下： public static void main(String[] args) throws IOException, InterruptedException { Process pid = Runtime.getRuntime().exec(\"javac\"); int exitValue = pid.waitFor(); System.out.println(\"Process exitValue: \" + exitValue); } 注：Process.exitValue()/Process.waitFor()获取外部程序的返回值为 0 表示执行成功，其余值表示外部程序执行出错。 综上：要解决IllegalThreadStateException异常， 要么就是手动捕获Process.exitValue()抛出的异常， 要么就使用Process.waitFor()（推荐）等待外部程序正常运行结束。 2 idea等ide的build区别 compile：只编译选定的目标。 make：只编译选定的目标，只编译上次编译后，产生过变化的文件。 build：对整个工程进行编译。 但现在都用第三方工具进行源码编译的管理，如：ant,maven等工具。 即maven的package、install等已经替代了ide提供的build。 3 ExecutorService API 控制线程池启停的接口。 ExecutorService Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-03 17:04:35 "}}