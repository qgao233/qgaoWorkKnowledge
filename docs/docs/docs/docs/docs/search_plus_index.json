{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 工作中碰到的一些知识。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 20:07:19 "},"2week/4_19/":{"url":"2week/4_19/","title":"测试与nio的Path,File","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 junit的Assert 2 Java 开发的模拟测试框架: Mockito 2.1 验证行为 2.2 Stub（存根/打桩） 2.3 参数匹配器 2.4 调用次数 2.5 简化Mock创建方式(注解) 2.6 间接依赖bean 2.7 @spy神器 2.8 api 3 nio的Path,File 3.1 路径 3.2 api 3.2.1 Paths 3.2.2 Path 3.2.3 Files 3.3 NIO和IO遍历指定目录效果对比 第2周-4.19 1 junit的Assert 2022-4-19 11:50:4 assert: 断言 junit断言总结 平时编写自己的测试类，如果没有断言，那么就没写测试的必要了。 JUnit框架用一组assert方法封装了最常见的测试任务。 junit中的assert方法全部放在Assert类中，都是静态方法。（因此可以静态引用） 方法 解释 assertTrue/False([String message,]boolean condition); 判断一个条件是true还是false fail([String message,]); 失败，可以有消息，也可以没有消息。 assertEquals([String message,]Object expected,Object actual); 判断是否相等，可以指定输出错误信息。第一个参数是期望值，第二个参数是实际的值。 assertNotNull/Null([String message,]Object obj); 判读一个对象是否非空(非空)。 assertSame/NotSame([String message,]Object expected,Object actual); 判断两个对象是否指向同一个对象。看内存地址。 failNotSame/failNotEquals(String message, Object expected, Object actual) 当不指向同一个内存地址或者不相等的时候，输出错误信息。 说白了，就是先提前断言（判断）想要得到的结果，如果与预想的不一致，Assert类就会抛出一个AssertionFailedError异常，Junit测试框架将这种错误归入Fails并且加以记录。 2 Java 开发的模拟测试框架: Mockito 2022-4-19 11:50:11 https://baijiahao.baidu.com/s?id=1727997644914260506&wfr=spider&for=pc https://blog.csdn.net/xiao__jia__jia/article/details/115252780 解决： 如何测试一个rest接口； 如何测试一个包含客户端调用服务端的复杂方法； 如何测试一个包含从数据库读取数据的复杂方法; ... 假设现在要测试method A, method A里面又依赖Method B、Method C、Method D，而依赖的这3个method又不好去构建（如ObsClient需要真实AK SK，HttpClient需要构建客户端与服务器，Database相对好构建，但是假设Method C只是从table1、table2联合查询，你还得分别往table1、table2 insert数据，很繁琐），这时候可以考虑Mockito进行优雅测试，当然如果你想去构建真实的测试场景，未免有点舍本逐末了 说白了，就是构造一些虚拟数据，来测试方法，避免大动干戈。 使用（可以静态引用）： 2.1 验证行为 一旦mock对象被创建了，mock对象会记住所有的交互。然后你就可以选择性的验证你感兴趣的交互，也就是说，你对这个Mock对象做的操作，都被记录下来了，验证的时候会是合法的。 @Test void testBehavior() { //构建moock数据 List list = mock(List.class); list.add(\"1\"); list.add(\"2\"); System.out.println(list.get(0)); // 会得到null ，前面只是在记录行为而已，没有往list中添加数据 verify(list).add(\"1\"); // 正确，因为该行为被记住了 verify(list).add(\"3\");//报错，因为前面没有记录这个行为 } 2.2 Stub（存根/打桩） 存根：用于预先说明当执行了什么操作的时候，产生一个什么响应， 存根特点：默认情况下，所有的函数都有返回值。 mock函数默认返回的是： null， 一个空的集合或者 一个被对象类型包装的内置类型，例如0、false对应的对象类型为Integer、Boolean； 测试桩函数可以被覆写 : 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；一旦测试桩函数被调用，该函数将会一致返回固定的值； 示例：常规存根，主要用到when 、thenReturn、then、thenThrow、thenAnswer这几个函数。 @Test void testStub() { List l = mock(ArrayList.class); when(l.get(0)).thenReturn(10); when(l.get(1)).thenReturn(20); when(l.get(2)).thenThrow(new RuntimeException(\"no such element\")); assertEquals(l.get(0), 10); assertEquals(l.get(1), 20); assertNull(l.get(4)); assertThrows(RuntimeException.class, () -> { int x = l.get(2); }); } void函数存根 主要用到doThrow(), doAnswer(), doNothing(), doReturn() and doCallRealMethod()等函数，当然，这些函数也可以用于有返回值的函数的存根； 需要注意的是，doCallRealMethod不能用于Mock对象，只能用于监察对象。 @Test void testVoidStub(){ List l = mock(ArrayList.class); doReturn(10).when(l).get(1); doThrow(new RuntimeException(\"you cant clear this List\")).when(l).clear(); assertEquals(l.get(1),10); assertThrows(RuntimeException.class,()->l.clear()); } 2.3 参数匹配器 在上面的stub测试中，我们需要对我们关系的数据一个一个的进行stub，如果数据过多的时候，会比较麻烦， 这个时候，我们可以利用参数匹配器来完成相应的操作，参数既可以用与stub，也可以用于验证的时候。 所有的参数匹配器都存放在org.mockito.ArgumentMatchers中。 @Test void testMatchers() { List l = mock(ArrayList.class); when(l.get(anyInt())).thenReturn(100); assertEquals(l.get(999),100); } 2.4 调用次数 校验某个操作执行的次数 @Test void testTimes() { List l = mock(ArrayList.class); when(l.get(anyInt())).thenReturn(100); System.out.println(l.get(0)); System.out.println(l.get(1)); System.out.println(l.get(1)); System.out.println(l.get(2)); System.out.println(l.get(2)); System.out.println(l.get(2)); System.out.println(l.get(2)); verify(l, times(7)).get(anyInt()); verify(l, atLeastOnce()).get(0); verify(l, atLeast(3)).get(2); verify(l, atMost(6)).get(2); verify(l, atMostOnce()).get(0); } 2.5 简化Mock创建方式(注解) 可以通过@Mock注解来简化Mock对象的创建过程，这样的话，我们就可以在多个测试中直接共用这些mock对象了， 需要注意的是，我们需要在方法开始执行下面的操作：MockitoAnnotations.initMocks @Mock private MyService myService; //会将MyService进行Mock @InjectMocks private MyController MyController; // 会向MyController注入Mock对象, 例如：myService @Before public void init() { MockitoAnnotations.initMocks(this); } 2.6 间接依赖bean 如果一个Bean A依赖于Bean B，而Bean B又依赖于Bean C，现在想对A的接口进行测试，又想把C Mock掉。 例如：MyFirstService 间接依赖了MyService, 下面演示如何将MyService进行隔离。 使用mock生成一个虚拟的对象，这样不需要在spring-test.xml文件单独配置这个myservice的Bean。 @Profile(\"development\") @Configuration public class MyServiceTestConfiguration { @Bean(name = \"myService\") @Primary // spring在寻找时，优先使用该bean public MyService myService() { return Mockito.mock(MyService.class); } } 测试: @ContextConfiguration(\"classpath:spring-test.xml\") @RunWith(SpringJUnit4ClassRunner.class) @ActiveProfiles(\"development\") public class myServiceImplTest { @Autowired private myFirstService myFirstService; } 2.7 @spy神器 spy类的原理是，如果不打桩默认都会执行真实的方法，如果打桩则返回桩实现。 对 spy 变量打桩时，如果使用 when 去设置模拟值时，他里面的代码逻辑依然会被执行，只是mock了返回结果； 使用 doReturn 设置模拟值的话，则不会出现这个问题！ A aSpy = spy(new A()); //aSpy.set...(); when(aSpy.service()).thenReturn(\"spy!\");//service()逻辑依然执行 doReturn(\"spy!\").when(aSpy).service();//service()不会执行 注意：spy后的实例，原有处理逻辑还在，但内部对象还得靠自己手动set进去 两个方法同个方法名，参数类型分别为Object 和 Collection， anyObject（）无法区分Object 和Collection，会导致程序走真实逻辑。 可以这样处理： anyCollection() 匹配Collection 和 any(MyClass.class) 2.8 api （一）Mockito org.mockito.Mockito是mockito提供的核心api，提供了大量的静态方法，用于帮助我们来mock对象，验证行为等等，然后需要注意的是，很多方法都被封装在了MockitoCore类里面，下面对一些常用的方法做一些介绍。 方法 解释 mock 构建一个我们需要的对象；可以mock具体的对象，也可以mock接口。 spy 构建监控对象 verify 验证某种行为 when 当执行什么操作的时候，一般配合thenXXX 一起使用。表示执行了一个操作之后产生什么效果。 doReturn 返回什么结果 doThrow 抛出一个指定异常 doAnswer 做一个什么相应，需要我们自定义Answer； times 某个操作执行了多少次 atLeastOnce 某个操作至少执行一次 atLeast 某个操作至少执行指定次数 atMost 某个操作至多执行指定次数 atMostOnce 某个操作至多执行一次 doNothing 不做任何处理 doReturn 返回一个结果 doThrow 抛出一个指定异常 doAnswer 指定一个操作，传入Answer doCallRealMethod 返回真实业务执行的结果，只能用于监控对象 （二）ArgumentMatchers 用于进行参数匹配，减少很多不必要的代码 方法 解释 anyInt 任何int类型的参数，类似的还有anyLong/anyByte等等。 eq 等于某个值的时候，如果是对象类型的，则看toString方法 isA 匹配某种类型 matches 使用正则表达式进行匹配 （三）OngoingStubbing OngoingStubbing用于返回操作的结果。 方法 解释 thenReturn 指定一个返回的值 thenThrow 抛出一个指定异常 then 指定一个操作，需要传入自定义Answer； thenCallRealMethod 返回真实业务执行的结果，只能用于监控对象。 3 nio的Path,File 2022-4-19 15:1:24 java7提供 在很多方面，java.nio.file.Path接口和java.io.File有相似性，但也有一些细微的差别。在很多情况下，可以用Path来代替File类。 3.1 路径 windows下绝对路径 Path path = Paths.get(\"c:\\\\data\\\\myfile.txt\"); //1 Path path = Paths.get(\"/home/jakobjenkov/myfile.txt\");//2. 会被解析成相对路径：base为C盘，从而对应绝对路径是：C:/home/jakobjenkov/myfile.txt linux下绝对路径 Path path = Paths.get(\"/home/jakobjenkov/myfile.txt\"); 3.2 api 3.2.1 Paths 方法 解释 Path get(String,...) 获得Path对象 3.2.2 Path 方法 解释 String toString() 返回调用 Path 对象的字符串表示形式 boolean starts With(String path) 判断是否以 path 路径开始 boolean ends With(String path) 判断是否以 path 路径结朿 boolean isAbsolute() 判断是否是绝对路径 Path getParento 返回Path对象包含整个路径，不包含 Path 对象指定的文件路径 Path getRoot() 返回调用 Path 对象的根路径 Path getFileName 返回与调用 Path 对象关联的文件名 int getNameCount() 返回Path 根目录后面元素的数量 Path getName (int idx) 返回指定索引位置idx 的路径名称 Path toAbsolute Path() 作为绝对路径返回调用 Path 对象 Path resolve(Path p) 合并两个路径，返回合并后的路径对应的Path对象 File toFile() 将Path转化为File类的对象 3.2.3 Files 1 用于操作文件或目录 方法 解释 Path copy(Path sc, Path dest, CopyOption ...how) 文件的复制 Path createDirectory(Path path, FileAttribute ...attr) 创建一个自录 Path createFile(Path path, FileAttribute ...arr) 创建一个文件 void delete (Path path) 删除一个文件/目录，如果不存在，执行报错 void deletelfExists (Path path) Path对应的文件/目录如果存在，执行删除 Path move(Path src. Path dest. CopyOption...how) 将src移动到dest 位置 long size(Path path) 返回 path 指定文件的大小 2 用于判断 方法 解释 boolean exists(Path path, LinkOption opts) 判断文件是否存在 boolean isDirectory(Path path, LinkOption opts) 判断是否是目录 boolean isRegularFile(Path path. LinkOption...opts) 判断是否是文件 boolean isHidden(Path path) 判断是否是隐薇文件 boolean isReadable(Path path) 判断文件是否可读 boolean isWritable(Path path) 判断文件是否可写 boolean notExists(Path path. LinkOptionu opts) 判断文件是否不存在 3 用于操作内容 方法 解释 SeekableByteChannel newByte Channel(Path path OpenOption...how) 获取与指定文件的连接，how 指定打开方式。 DirectoryStream newDirectoryStream(Path path) 打开path指定的目录 InputStream newlnputStream(Path path. OpenOption ... how) 获取InputStream对象 OutputStream newOutputStream(Path path, OpenOption ... how) 获取OutputStream对象 4 其它 Files.lines() 以Stream流的形式读取文件的所有行 /** * 以流的形式读取文件的所有行 * 读取的的字节是以UTF-8解码的字符集 * * @param path 文件的路径 * @return Stream 文件中的行组成的流 * @throws IOException 出现IO错误时抛出该异常 * @throws SecurityException 如果是默认提供程序,则安全管理器是已安装,检查读取方法来检查对文件的读取访问 */ public static Stream lines(Path path) throws IOException {} /** * 以流的形式读取文件的所有行 * 该方法和readAllLines不同,不会将所有行读取到一个List中,而是以流的形式进行惰性加载 * 以指定的解码的字符集读取字节,支持readAllLines的行终止符 * 当该方法返回时,后续读取文件发生的IOException将会在读取Stream流的方法处抛出一个包装的UncheckedIOException. * 如果关闭文件发生IOException也会包装成为一个UncheckedIOException * 返回的流封装了一个读取器,如果需要周期性的读取文件，需要使用try-with-resources语句来保证stream的close方法被调用,从而关闭打开的文件 * * @param path 文件的路径 * @param cs 指定的解码格式 * @return Stream 文件中的行组成的流 * @throws IOException 出现IO错误时抛出该异常 * @throws SecurityException 如果是默认提供程序,则安全管理器是已安装,检查读取方法来检查对文件的读取访问 */ public static Stream lines(Path path, Charset cs) throws IOException {} 3.3 NIO和IO遍历指定目录效果对比 利用IO的File递归遍历目录： public static void showPath(String dir){ File files = new File(dir); if (files.isDirectory()) { for (File file: files.listFiles() ) { System.out.println(file.getAbsolutePath()); showPath(file.getAbsolutePath().toString()); } }else{ return; } } 采用NIO的Files.walk方法，借助Stream流 直接逐一把目录打印出来： public static void printDir(String dir){ Path path = Paths.get(dir); try { Files.walk(path).forEach(System.out::println); } catch (IOException e) { e.printStackTrace(); } } 汽车为你造好了，没必要再骑车上高速了。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 14:51:55 "},"2week/4_20/":{"url":"2week/4_20/","title":"maven","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 maven 1.1 生命周期 1.2 maven寻找依赖流程 1.3 idea里的maven wrapper 第2周-4.20 1 maven 2022-4-20 9:57:7 1.1 生命周期 1 compile mvn compile会在当前目录生成target目录。 2 clean mvn clean删除当前目录中的target目录。 3 package mvn package将本地工程打包成jar包。 4 install mvn install将本地工程打包成jar包，放入到本地仓库中。 之后，其它Maven管理的项目可以通过pom.xml配置依赖引入到其工程。 其它 mvn -DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。 mvn -Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。 1.2 maven寻找依赖流程 Maven 将从本地资源库获得 Maven 的本地资源库依赖资源(默认用户目录下的.m2目录)，如果没有找到， 它会从默认的 Maven 中央存储库 – http://repo1.maven.org/maven2/ 查找下载，如果还是没有找到， 它会从配置的远程存储库（包括私服、JBOSS仓库和java.net仓库）查找下载。 1.3 idea里的maven wrapper 要使用maven wrapper有2种方式： 1、 主动生成： mvn -N io.takari:maven:0.7.6:wrapper 会生成3个文件： mvnw(linux命令) mvnw.cmd(windows命令) .mvn目录 2、从别的项目中将这3个文件copy过来 有了这3个文件后， maven的具体版本只依赖于当前项目中(.mvn/wrapper/maven-wrapper.properties)所配置的maven版本。 在项目目录下，使用mvnw代替以前的mvn命令。 mvnw会在每次执行命令时检测${home}/.m2/wrapper/dists目录下是否有maven-wrapper.properties中指定Maven版本，如果没有就将maven环境自动下载到dists目录。 maven的配置文件settings.xml必须在{user}/.m2目录下 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-20 13:40:43 "},"2week/4_22/":{"url":"2week/4_22/","title":"idea的git标签中的符号含义","keywords":"","body":"第2周-4.22 1 idea的git标签中的符号含义 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-22 15:03:58 "},"3week/4_27/":{"url":"3week/4_27/","title":"linux -- less","keywords":"","body":"第3周-4.27 1 linux -- less less is more. less [-options] []表示可选，<>表示必选 options desc -b 《缓冲区大小》 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o 《文件名》 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x 《数字》 将“tab”键显示为规定的数字空格 常用命令：less -mN 在查看期间，可通过以下命令来操作阅读文件： 当往下看浏览的时候，后代表下，前代表上； 当往上看浏览的时候，后代表上，前代表下。 operation desc /str 向后搜索“str”的功能 ?str 向前搜索“str”的功能 n 重复前一个搜索(与 / 或 ? 有关) N 反向重复前一个搜索(与 / 或 ? 有关) b 向前翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 g 跳到文件头 【常用】 G 跳到文件尾部 【常用】 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-04-28 10:35:03 "},"4week/5_3/":{"url":"4week/5_3/","title":"java里执行第三方脚本","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 java里执行第三方脚本 1.1 Process.exitValue() 1.2 Process.waitFor() 2 idea等ide的build区别 3 ExecutorService API 第4周-5.3 1 java里执行第三方脚本 When Runtime.exec() won't 简析 Runtime.exec(..) java 程序中，如果我们想执行一些 Shell 命令或其他外部应用程序，通常都是使用java.lang.Runtime.exec(..)方法来执行的。 当 Java 内置的 Runtime.exec(..) 方法在执行外部命令时，可能存在一些不易察觉的坑，往往会导致程序运行失败。 1.1 Process.exitValue() IllegalThreadStateException异常：Runtime.exe(..)可能出现IllegalThreadStateException异常。我们通常使用exec(..)方法执行 JVM 外部程序，如果想查看外部程序返回值，可以使用Process.exitValue()方法。 需要注意的是，如果直接使用Process.exitValue()获取外部程序返回值，如果此时外部程序还未运行完成，则会抛出IllegalThreadStateException异常。 举个栗子：比如在 Java 中执行 javac 程序，并获取其返回值。 代码如下： public class BadExecJavac { public static void main(String[] args) throws IOException { Process pid = Runtime.getRuntime().exec(\"javac\"); int exitValue = pid.exitValue(); System.out.println(\"Process exitValue: \" + exitVal); } } 使用Process.waitFor()替换Process.exitValue()。 1.2 Process.waitFor() Process.waitFor()与Process.exitValue()同样会返回外部程序的执行结果，但是它会阻塞直到外部程序运行结束。 代码如下： public static void main(String[] args) throws IOException, InterruptedException { Process pid = Runtime.getRuntime().exec(\"javac\"); int exitValue = pid.waitFor(); System.out.println(\"Process exitValue: \" + exitValue); } 注：Process.exitValue()/Process.waitFor()获取外部程序的返回值为 0 表示执行成功，其余值表示外部程序执行出错。 综上：要解决IllegalThreadStateException异常， 要么就是手动捕获Process.exitValue()抛出的异常， 要么就使用Process.waitFor()（推荐）等待外部程序正常运行结束。 2 idea等ide的build区别 compile：只编译选定的目标。 make：只编译选定的目标，只编译上次编译后，产生过变化的文件。 build：对整个工程进行编译。 但现在都用第三方工具进行源码编译的管理，如：ant,maven等工具。 即maven的package、install等已经替代了ide提供的build。 3 ExecutorService API 控制线程池启停的接口。 ExecutorService Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-03 17:04:35 "},"4week/5_4/":{"url":"4week/5_4/","title":"spring batch","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 spring batch 1.1 Job 1.1.1 JobInstance 1.1.2 JobParameters 1.1.3 JobExecution 1.2 Step 1.2.1 StepExecution 1.2.2 ExecutionContext 1.3 JobRepository 1.4 JobLauncher 1.5 Item Reader 1.6 Item Processor 1.7 Item Writer 1.8 chunk 处理流程 1.9 skip策略和失败处理 1.10 批处理操作指南 1.10.1 批处理原则 1.10.2 如何默认不启动job 1.11 @stepScope 第4周-5.4 1 spring batch 批处理框架 spring batch 这么强，你会用吗？ 一个典型的批处理应用程序大致如下： 读：从数据库，文件或队列中读取大量记录。 处理：以某种方式处理数据。 写：以修改之后的形式写回数据。 其对应的示意图如下： spring batch的一个总体的架构如下： 在spring batch中一个job可以定义很多的步骤step， 在每一个step里面可以定义其专属的 ItemReader用于读取数据， ItemProcesseor用于处理数据， ItemWriter用于写数据， 而每一个定义的job则都在JobRepository里面， 我们可以通过JobLauncher来启动某一个job。 1.1 Job Job和Step是spring batch执行批处理任务最为核心的两个概念。 Job是一个封装整个批处理过程的一个概念。Job在spring batch的体系当中只是一个最顶层的一个抽象概念，体现在代码当中则它只是一个最上层的接口，其代码如下: /** * Batch domain object representing a job. Job is an explicit abstraction * representing the configuration of a job specified by a developer. It should * be noted that restart policy is applied to the job as a whole and not to a * step. */ public interface Job{ String getName( ) ; boolean isRestartable( ) ; void execute( JobExecution execution) ; JobParametersIncrementer getJobParametersIncrementer( ) ; JobParametersValidator getJobParametersValidator( ) ; } 在Job这个接口当中定义了五个方法，它的实现类主要有两种类型的job， 一个是simplejob， 另一个是flowjob。 在spring batch当中，job是最顶层的抽象，除job之外我们还有JobInstance以及JobExecution这两个更加底层的抽象。 一个job是我们运行的基本单位，它内部由step组成。job本质上可以看成step的一个容器。 一个job可以按照指定的逻辑顺序组合step，并提供了我们给所有step设置相同属性的方法，例如一些事件监听，跳过策略。 Spring Batch以SimpleJob类的形式提供了Job接口的默认简单实现，它在Job之上创建了一些标准功能。 一个使用java config的例子代码如下： @Bean public Job footballJob { return this.jobBuilderFactory.get(\"footballJob\") .start(playerLoad) .next(gameLoad) .next(playerSummarization) .end .build; } 这个配置的意思是：首先给这个job起了一个名字叫footballJob，接着指定了这个job的三个step，他们分别由方法: playerLoad, gameLoad, playerSummarization 实现。 1.1.1 JobInstance 在上文已经提到了JobInstance，他是Job的更加底层的一个抽象，他的定义如下： public interface JobInstance { /** * Get unique id for this JobInstance. * @return instance id */ public long getInstanceId; /** * Get job name. * @return value of 'id' attribute from */ public String getJobName; } 方法很简单，一个是返回Job的id，另一个是返回Job的名字。 JobInstance指的是job运行当中，作业执行过程当中的概念。Instance本就是实例的意思。 比如说现在有一个批处理的job，它的功能是在一天结束时执行行一次。我们假定这个批处理job的名字为'EndOfDay'。在这个情况下，那么每天就会有一个逻辑意义上的JobInstance, 而我们必须记录job的每次运行的情况。 1.1.2 JobParameters 在上文当中我们提到了，同一个job每天运行一次的话，那么每天都有一个jobIntsance，但他们的job定义都是一样的，那么我们怎么来区别一个job的不同jobinstance了。 不妨先做个猜想，虽然jobinstance的job定义一样，但是他们有的东西就不一样，例如运行时间。 因此，我们可以通过把运行时间当作Jobparameter来操作正确的JobInstance。 1.1.3 JobExecution JobExecution指的是单次尝试运行一个我们定义好的Job的代码层面的概念。 job的一次执行可能以失败也可能成功。只有当执行成功完成时，给定的JobExecution与执行相对应的JobInstance才也被视为完成。 还是以前面描述的EndOfDay的job作为示例，假设第一次运行01-01-2019的JobInstance结果是失败。那么此时如果使用与第一次运行相同的Jobparameter参数（即01-01-2019）作业参数再次运行，那么就会创建一个对应于之前jobInstance的一个新的JobExecution实例,JobInstance仍然只有一个。 JobExecution的接口定义如下： public interface JobExecution{ /** * Get unique id for this JobExecution. * @return execution id */ public longget ExecutionId( ) ; /** * Get job name. * @return value of 'id' attribute from */ public String getJobName( ) ; /** * Get batch status of this execution. * @return batch status value. */ public BatchStatus getBatchStatus( ) ; /** * Get time execution entered STARTED status. * @return date (time) */ public Date getStartTime( ) ; /** * Get time execution entered end status: COMPLETED, STOPPED, FAILED * @return date (time) */ public Date getEndTime( ) ; /** * Get execution exit status. * @return exit status. */ public String getExitStatus( ) ; /** * Get time execution was created. * @return date (time) */ public Date getCreateTime( ) ; /** * Get time execution was last updated updated. * @return date (time) */ public Date getLastUpdatedTime( ) ; /** * Get job parameters for this execution. * @return job parameters */ public Properties getJobParameters( ) ; } 只提一下BatchStatus，JobExecution当中提供了一个方法getBatchStatus用于获取一个job某一次特地执行的一个状态。 BatchStatus是一个代表job状态的枚举类，其定义如下： public enum BatchStatus{ STARTING, STARTED, STOPPING, STOPPED, FAILED, COMPLETED, ABANDONED } 这些属性对于一个job的执行来说是非常关键的信息，并且spring batch会将他们持久到数据库当中. 在使用Spring batch的过程当中spring batch会自动创建一些表用于存储一些job相关的信息，用于存储JobExecution的表为batch_job_execution。 1.2 Step 每一个Step对象都封装了批处理作业的一个独立的阶段。事实上，每一个Job本质上都是由一个或多个步骤组成。每一个step包含定义和控制实际批处理所需的所有信息。任何特定的内容都由编写Job的开发人员自行决定。 一个step可以非常简单也可以非常复杂。例如，一个step的功能是将文件中的数据加载到数据库中，那么基于现在spring batch的支持则几乎不需要写代码。更复杂的step可能具有复杂的业务逻辑，这些逻辑作为处理的一部分。 与Job一样，Step具有与JobExecution类似的StepExecution，如下图所示： 1.2.1 StepExecution StepExecution表示一次执行Step, 每次运行一个Step时都会创建一个新的StepExecution，类似于JobExecution。但是，某个步骤可能由于其之前的步骤失败而无法执行。且仅当Step实际启动时才会创建StepExecution。 一次step执行的实例由StepExecution类的对象表示。每个StepExecution都包含对其相应步骤的引用以及JobExecution和事务相关的数据，例如提交和回滚计数以及开始和结束时间。 此外，每个步骤执行都包含一个ExecutionContext，其中包含开发人员需要在批处理运行中保留的任何数据，例如重新启动所需的统计信息或状态信息。 1.2.2 ExecutionContext ExecutionContext即每一个StepExecution 的执行环境。它包含一系列的键值对。我们可以用如下代码获取ExecutionContext: ExecutionContextecStep = stepExecution.getExecutionContext; ExecutionContextecJob = jobExecution.getExecutionContext; 1.3 JobRepository JobRepository是一个用于将上述job，step等概念进行持久化的一个类。它同时给Job和Step以及下文会提到的JobLauncher实现提供CRUD操作。 首次启动Job时，将从repository中获取JobExecution，并且在执行批处理的过程中，StepExecution和JobExecution将被存储到repository当中。 @EnableBatchProcessing注解可以为JobRepository提供自动配置。 1.4 JobLauncher JobLauncher这个接口的功能非常简单，它是用于启动指定了JobParameters的Job，为什么这里要强调指定了JobParameter，原因其实我们在前面已经提到了，jobparameter和job一起才能组成一次job的执行。 public interface JobLauncher{ public JobExecution run(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException; } 上面run方法实现的功能是根据传入的job以及jobparamaters从JobRepository获取一个JobExecution并执行Job。 1.5 Item Reader ItemReader是一个读数据的抽象，它的功能是为每一个Step提供数据输入。 当ItemReader以及读完所有数据时，它会返回null来告诉后续操作数据已经读完。 Spring Batch为ItemReader提供了非常多的有用的实现类，比如JdbcPagingItemReader，JdbcCursorItemReader等等。 ItemReader支持的读入的数据源也是非常丰富的，包括各种类型的数据库，文件，数据流，等等。几乎涵盖了我们的所有场景。 下面是一个JdbcPagingItemReader的例子代码： @Bean public JdbcPagingItemReader itemReader(DataSource dataSource, PagingQueryProvider queryProvider) { Map parameterValues = new HashMap<>(); parameterValues.put( \"status\", \"NEW\"); return new JdbcPagingItemReaderBuilder () .name( \"creditReader\") .dataSource(dataSource) .queryProvider(queryProvider) .parameterValues(parameterValues) .rowMapper(customerCreditMapper) .pageSize( 1000) .build; } @Bean public SqlPagingQueryProviderFactoryBean queryProvider { SqlPagingQueryProviderFactoryBean provider = new SqlPagingQueryProviderFactoryBean(); provider.setSelectClause( \"select id, name, credit\"); provider.setFromClause( \"from customer\"); provider.setWhereClause( \"where status=:status\"); provider.setSortKey( \"id\"); return provider; } JdbcPagingItemReader必须指定一个PagingQueryProvider，负责提供SQL查询语句来按分页返回数据。 下面是一个JdbcCursorItemReader的例子代码: private JdbcCursorItemReader> buildItemReader(final DataSource dataSource, StringtableName, Stringtenant) { JdbcCursorItemReader> itemReader = new JdbcCursorItemReader<>(); itemReader.setDataSource(dataSource); itemReader.setSql( \"sql here\"); itemReader.setRowMapper( newRowMapper); return itemReader; } 1.6 Item Processor ItemProcessor对项目的业务逻辑处理的一个抽象, 当ItemReader读取到一条记录之后，ItemWriter还未写入这条记录之前，我们可以借助ItemProcessor提供一个处理业务逻辑的功能，并对数据进行相应操作。 如果我们在ItemProcessor发现一条数据不应该被写入，可以通过返回null来表示。ItemProcessor和ItemReader以及ItemWriter可以非常好的结合在一起工作，他们之间的数据传输也非常方便。我们直接使用即可。 1.7 Item Writer 既然ItemReader是读数据的一个抽象，那么ItemWriter自然就是一个写数据的抽象，它是为每一个step提供数据写出的功能。写的单位是可以配置的，我们可以一次写一条数据，也可以一次写一个chunk的数据，关于chunk下文会有专门的介绍。ItemWriter对于读入的数据是不能做任何操作的。 Spring Batch为ItemWriter也提供了非常多的有用的实现类，当然我们也可以去实现自己的writer功能。 1.8 chunk 处理流程 spring batch提供了让我们按照chunk处理数据的能力，一个chunk的示意图如下： 所图所示，由于我们一次batch的任务可能会有很多的数据读写操作，因此一条一条的处理并向数据库提交的话效率不会很高，因此spring batch提供了chunk这个概念，我们可以设定一个chunk size，spring batch 将一条一条处理数据，但不提交到数据库，只有当处理的数据数量达到chunk size设定的值的时候，才一起去commit. java的实例定义代码如下： @Bean public Job sampleJob(){ return this.jobBuilderFactory.get(\"sampleJob\") .start(step1()) .end() .build(); } @Bean public Step step1() { return this. stepBuilderFactory.get (\"step1\") .chunk(10) .reader(itemReader()) .writer(itemWriter()) .build(); } 在上面这个step里面，chunk size被设为了10，当ItemReader读的数据数量达到10的时候，这一批次的数据就一起被传到itemWriter，同时transaction被提交。 1.9 skip策略和失败处理 一个batch的job的step，可能会处理非常大数量的数据，难免会遇到出错的情况，出错的情况虽出现的概率较小，但是我们不得不考虑这些情况，因为我们做数据迁移最重要的是要保证数据的最终一致性。 spring batch当然也考虑到了这种情况，并且为我们提供了相关的技术支持，请看如下bean的配置： @Bean public Step step1() { return this. stepBuilderFactory.get(\"step1\") .chunk(10) .reader(flatFileItemReader()) .writer(itemwriter()) .faultTolerant() .skipLimit(10) .skip(Exception.class) .noSkip(FileNotFoundException.class) .build(); 我们需要留意这三个方法，分别是: skipLimit: 意思是我们可以设定一个我们允许的这个step可以跳过的异常数量，假如我们设定为10，则当这个step运行时，只要出现的异常数目不超过10，整个step都不会fail。注意，若不设定skipLimit，则其默认值是0. skip: 我们可以指定我们可以跳过的异常，因为有些异常的出现，我们是可以忽略的。 noSkip: 指出现这个异常我们不想跳过，也就是从skip的所有exception当中排除这个exception，从上面的例子来说，也就是跳过所有除FileNotFoundException的exception。 那么对于这个step来说，FileNotFoundException就是一个fatal的exception，抛出这个exception的时候step就会直接fail。 1.10 批处理操作指南 一些使用spring batch时的值得注意的点 1.10.1 批处理原则 在构建批处理解决方案时，应考虑以下关键原则和注意事项。 批处理体系结构通常会影响体系结构 尽可能简化并避免在单批应用程序中构建复杂的逻辑结构 保持数据的处理和存储在物理上靠得很近（换句话说，将数据保存在处理过程中）。 最大限度地减少系统资源的使用，尤其是I / O. 在internal memory中执行尽可能多的操作。 查看应用程序I / O（分析SQL语句）以确保避免不必要的物理I / O. 特别是，需要寻找以下四个常见缺陷： 当数据可以被读取一次并缓存或保存在工作存储中时，读取每个事务的数据。 重新读取先前在同一事务中读取数据的事务的数据。 导致不必要的表或索引扫描。 未在SQL语句的WHERE子句中指定键值。 在批处理运行中不要做两次一样的事情。例如，如果需要数据汇总以用于报告目的，则应该（如果可能）在最初处理数据时递增存储的总计，因此您的报告应用程序不必重新处理相同的数据。 在批处理应用程序开始时分配足够的内存，以避免在此过程中进行耗时的重新分配。 总是假设数据完整性最差。插入适当的检查和记录验证以维护数据完整性。 尽可能实施校验和以进行内部验证。例如，对于一个文件里的数据应该有一个数据条数纪录，告诉文件中的记录总数以及关键字段的汇总。 在具有真实数据量的类似生产环境中尽早计划和执行压力测试。 在大批量系统中，数据备份可能具有挑战性，特别是如果系统以24-7在线的情况运行。数据库备份通常在在线设计中得到很好的处理，但文件备份应该被视为同样重要。如果系统依赖于文件，则文件备份过程不仅应该到位并记录在案，还应定期进行测试。 1.10.2 如何默认不启动job 在使用java config使用spring batch的job时，如果不做任何配置，项目在启动时就会默认去跑我们定义好的批处理job。那么如何让项目在启动时不自动去跑job呢？ spring batch的job会在项目启动时自动run，如果我们不想让他在启动时run的话，可以在application.properties中添加如下属性： spring.batch.job.enabled= false 在读数据时内存不够 在使用spring batch做数据迁移时，发现在job启动后，执行到一定时间点时就卡在一个地方不动了，且log也不再打印，等待一段时间之后，得到如下错误： 红字的信息为：Resource exhaustion event：the JVM was unable to allocate memory from the heap. 翻译过来的意思就是项目发出了一个资源耗尽的事件，告诉我们java虚拟机无法再为堆分配内存。 造成这个错误的原因是: 这个项目里的batch job的reader是一次性拿回了数据库里的所有数据，并没有进行分页，当这个数据量太大时，就会导致内存不够用。解决的办法有两个: 调整reader读数据逻辑，按分页读取，但实现上会麻烦一些，且运行效率会下降 增大service内存 1.11 @stepScope Spring Batch中@StepScope的适用范围及理解 先说一下IOC容器中几种bean的作用范围(scope): singleton: 全局有且仅有一个实例 prototype: 每次获取Bean的时候会有一个新的实例 request: request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session: session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 globalsession: global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义 使用Spring Batch批处理框架时,batch框架中特有的bean作用范围注解@StepScope， xml配置为 Spring batch框架只有在批处理时才需要实例化job以及对应的最底层处理单位(reader,processor,writer,tasklet) 而job启动后的运行参数一旦确定便无法修改。 为了使每一次启动job时使处理单位的参数可以动态修改(比如第一次job启动时参数tranDate=\"20210101\",第二次job参数启动时参数改为tranDate=\"20210102\"). 所以设计了@StepScope配合@Value(\"#{jobParameters['contractInfoDat']}\") 从job的启动参数中获取所需参数。 @StepScope只能用在最底层处理单位(reader,processor,writer,tasklet)的方法上,配合@Bean使用。 被@StepScope注解修饰的bean只会在step启动时进行初始化,step处理完成后便会被销毁,即同一个Step执行两次你会发现Writer创建了两次。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-04 19:00:31 "},"4week/5_5/":{"url":"4week/5_5/","title":"spring中单例bean引用原型bean","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 spring中单例bean引用原型bean 1.1 场景：单例bean引用不变的原型对象 1.1.1 xml文件内容 1.1.2 测试和结果 1.2 保证单例bean引用的原型始终是新建对象 1.2.1 更新xml文件 1.2.2 测试和结果 1.3 源码原理 1.3.1 初始化设置属性 1.3.2 执行getHeadMaster和getStudent后 2 StringBuffer清空操作 3 stream 3.1 介绍 3.2 生命周期 3.3 操作api 3.3.1 创建流 3.3.2 中间操作 3.3.3 终端操作 3.4 总结 4 Files.lines使用注意事项 4.1 使用try-with-resources 5 spring xml bean的property的简写——p命令空间 第4周-5.5 1 spring中单例bean引用原型bean spring中单例bean引用原型bean 1.1 场景：单例bean引用不变的原型对象 1.1.1 xml文件内容 定义headMaster和student对原型bean，teacher为单例bean。其中teacher中注入headMaster和student属性。 1.1.2 测试和结果 单例bean的teacher中，headMaster和student属性始终不变。从applicationContext中重新获取对应bean后，返回新建对象。 public static void main(String[] args) { ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean/scope/scope.xml\"); Teacher teacher = ac.getBean(\"teacher\", Teacher.class); HeadMaster headMaster = teacher.getHeadMaster(); Student student = teacher.getStudent(); HeadMaster headMasterTwo = teacher.getHeadMaster(); Student studentTwo = teacher.getStudent(); System.out.println(headMaster); System.out.println(headMasterTwo); System.out.println(ac.getBean(\"headMaster\", HeadMaster.class)); System.out.println(student); System.out.println(studentTwo); System.out.println(ac.getBean(\"student\", Student.class)); } /* * com.spring.learn.common.staff.HeadMaster@569cfc36 * com.spring.learn.common.staff.HeadMaster@569cfc36 * com.spring.learn.common.staff.HeadMaster@33723e30 * com.spring.learn.common.staff.Student@64f6106c * com.spring.learn.common.staff.Student@64f6106c * com.spring.learn.common.staff.Student@553a3d88 */ 1.2 保证单例bean引用的原型始终是新建对象 引入 lookup-method或者 replace-method。 1.2.1 更新xml文件 1.2.2 测试和结果 public static void main(String[] args) { ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"bean/scope/scope2.xml\"); Teacher teacher = ac.getBean(\"teacher\", Teacher.class); HeadMaster headMaster = teacher.getHeadMaster(); Student student = teacher.getStudent(); HeadMaster headMasterTwo = teacher.getHeadMaster(); Student studentTwo = teacher.getStudent(); System.out.println(headMaster); System.out.println(headMasterTwo); System.out.println(ac.getBean(\"headMaster\", HeadMaster.class)); System.out.println(student); System.out.println(studentTwo); System.out.println(ac.getBean(\"student\", Student.class)); } /* * com.spring.learn.common.staff.HeadMaster@6b67034 * com.spring.learn.common.staff.HeadMaster@16267862 * com.spring.learn.common.staff.HeadMaster@71248c21 * com.spring.learn.common.staff.Student@442675e1 * com.spring.learn.common.staff.Student@6166e06f * com.spring.learn.common.staff.Student@49e202ad */ 1.3 源码原理 本质上就是对getStudent和getHeadMaster加一层cglib代理，每次执行方法前会经过拦截器，返回application.getBean方法返回的bean对象。 1.3.1 初始化设置属性 初始化teacher时， AbstractAutowireCapableBeanFactory类中的: // lookup-method标签识别入口 522行：mbdToUse.prepareMethodOverrides(); AbstractBeanDefinition类中的: // BeanDefinition类中的参数methodOverrides，中的参数overrides>。 // MethodOverride中的属性参数overloaded 设置为false 1134行：getMethodOverrides().getOverrides().forEach(this::prepareMethodOverride); 1.3.2 执行getHeadMaster和getStudent后 CglibSubclassingInstantiationStrategy类中的intercept方法: // 从当前bean的BeanDefinition信息中，获取重写方法列表中的lookup方法对象。 // 根据此对象信息完成指定对象的实例化 238行：LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method); // 返回 根据xml文件中lookup-method指定bean值，从applicationContext中获取bean的对象。 242行：Object bean = (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) : this.owner.getBean(lo.getBeanName())); 2 StringBuffer清空操作 StringBuffer清空操作delete和setLength的效率对比分析 setLength()方法用时较短，因此在StringBuffer 清空操作中，使用setLength(int newLength)方法效率较高。 3 stream 「再学一次系列」一文弄懂Stream API，基操勿6 3.1 介绍 流的主要目的就是进行表达计算。 stream流是通过一组原始数据源转化生成的元素序列，支持: 数据处理操作（类似数据库的部分操作） 类其他函数式编程语言中的常用操作，如：filter、map等 3.2 生命周期 类似于一瓶矿泉水的生产： 获取水源（准备原始数据）：生成流的元素序列； 进入工作台（多个工作台）：流的中间操作，可以有多个中间操作进行衔接，中间操作返回的结果还是一个流； 装瓶（结束工作）：流的终端操作，无返回值，或返回一个非流结果。 3.3 操作api 3.3.1 创建流 创建流的方式常见包括： Collections.stream() Stream.of(args) 创建初始流，包含三个属性(值)： 姓名（卡诺1 - 卡诺5） 年龄（11 - 15） 性别（0 / 1） 后续操作均基于此数据: /** * 初始化用户元素序列 * @return */ public Stream userStream() { // 初始化集合数据 List users = new ArrayList<>(); for (int i = 0; i 3.3.2 中间操作 1 filter 过滤器 接受一个Predicate表达式，筛选满足条件的数据. public void testFilter(){ userStream().filter(user -> user.getAge() > 14)// 筛选出年龄大于14岁的user .forEach(System.out::println); // 遍历: User(name=卡诺5, age=15, gender=0) } 注意：forEach为终端操作 2 sort 排序 存在重载方法， sorted(), sorted(Comparator comparator) public void testSort(){ userStream() .sorted((u1, u2) -> u2.getAge() - u1.getAge()) // 增加一个比较器，按照年龄降序 .forEach(System.out::println); // 遍历，倒叙输出所有 } 3 limit 截断流 获取指定个数的元素，如果实际小于指定数，那么有多少返回多少。 userStream() .sorted((u1, u2) -> u2.getAge() - u1.getAge())// 增加一个比较器，按照年龄降序 .limit(1) // 获取排序后的第一个数据 .forEach(System.out::println); // 遍历: User(name=卡诺5, age=15, index=0) 4 skip 跳过 跳过指定个数元素，如果实际小于指定数，那么返回一个空流 userStream() .skip(4) // 跳过前四个 .forEach(System.out::println); // 遍历: User(name=卡诺5, age=15, index=0) 5 distinct 去重 如果操作的元素是对象，则依据对象的hashcode和equals进行去重。 Stream.of(1, 1, 3, 2, 3) .distinct() // 去重 .forEach(System.out::print); // 132 6 map 映射 将流中元素通过操作变成新的元素，接受一个Function表达式。 userStream() .map(User::getName) // 映射出所有名字 .forEach(System.out::print); // 卡诺1卡诺2卡诺3卡诺4卡诺5 7 flatMap 映射 将元素变成新的流，然后把多个新的流再变成一个流 // 将名字构建成Stream流 Function> flatMapFunction = user -> Stream .builder() .add(user.getName()) .build(); // map userStream() .map(flatMapFunction) // 接收一个Stream .forEach(System.out::println); // java.util.stream.ReferencePipeline$Head@7a1ebcd8 // flatMap userStream() .flatMap(flatMapFunction) // 接收一个Stream .forEach(System.out::print); // 卡诺1卡诺2卡诺3卡诺4卡诺5 通过上面的案例可以看出，map返回的是名字构建成Stream流，flatMap则是将返回的流的泛型值平铺合并成一个新的数据元素序列。 3.3.3 终端操作 1 forEach 遍历元素 userStream().forEach(System.out::println); 2 count 统计总数 类似SQL中的count，统计数据 long count = userStream().count(); System.out.println(count); // 5 3 max 获取最大值 max参数为比较器函数，返回类型是Optional Integer max = Stream.of(1, 2, 3, 4) .max(Comparator.comparingInt(t -> t)) .get(); System.out.println(max); // 4 注意： Comparator.comparingInt(t -> t) 与(t1, t2)-> t1 - t2等价，是Java为我们封装好的Lambda写法。 4 min 获取最小值 与max用法一致 Integer min = Stream.of(1, 2, 3, 4) .min(Comparator.comparingInt(t -> t)) .get(); System.out.println(min); // 1 5 findFirst 获取第一个 返回类型是Optional，如果值不存在，返回的是空的Optional Optional firstUser = userStream().findFirst(); System.out.println(firstUser.get()); // User(name=卡诺1, age=11, gender=0) 6 findAny 获取任意一个 使用方式类比findFirst，获取任意一个(串行流中一般返回的是第一个，并行流中是随机的) // 串行流 Optional findAny = Stream.of(1, 2, 3, 4).findAny(); System.out.println(findAny.get()); // 并行流 Optional findAny2 = Stream.of(1, 2, 3, 4).parallel().findAny(); System.out.println(findAny2.get()); 注意： parallel()可以将串行流转化成并行流 allMatch、anyMatch、noneMacth 接收一个Predicate类型的表达式 7 allMacth 全部匹配 // 判断元素是否都大于3 Predicate predicate = (i) -> i > 3; boolean allGt3 = Stream.of(1, 2, 3, 4).allMatch(predicate); System.out.println(allGt3); // false allGt3 = Stream.of(4, 5, 6).allMatch(predicate); System.out.println(allGt3); // true 8 anyMatch 至少匹配一个 // 判断是否存在大于3的元素 Predicate predicate = (i) -> i > 3; boolean anyGt3 = Stream.of(1, 2).anyMatch(predicate); System.out.println(anyGt3); // false anyGt3 = Stream.of(4, 5, 6).anyMatch(predicate); System.out.println(anyGt3); // true 9 noneMacth 没有匹配到任何一个 // 判断是否存在大于3的元素 Predicate predicate = (i) -> i > 3; boolean anyGt3 = Stream.of(1, 2).noneMatch(predicate); System.out.println(anyGt3); // true anyGt3 = Stream.of(4, 5, 6).noneMatch(predicate); System.out.println(anyGt3); // false 10 reduce 归约 将元素序列通过指定的算法反复结合，最终得到一个结果，一般用来计算sum等，reduce是个重载方法，包含 单参: reduce(BinaryOperator accumulator) 双参数: reduce(T identity, BinaryOperator accumulator), 第一个入参可以认为是一个初始化数据 三参数: reduce(U identity, BiFunction accumulator, BinaryOperator combiner), 第三个参数在串行流中不触发，效果等同与双参，但在并行流它用于合并计算 // 求和 【单参】 Optional reduceOptional = Stream.of(1, 2).reduce(Integer::sum); System.out.println(reduceOptional.get()); // 3 // 求和，增加一个初始化值参与计算 【双参】 Integer reduce = Stream.of(1, 2).reduce(1, Integer::sum); System.out.println(reduce); // 4 // 并行流三参 Integer sum = Stream.of(1, 2, 3).parallel().reduce(4, (t1, t2) -> { String log = String.join(\" | \",\"中间参数\", Thread.currentThread().getName(), t1 + \" + \" + t2); System.out.println(log); return t1 + t2; }, (t1, t2) -> { String log = String.join(\" | \", \"第三个参数\", Thread.currentThread().getName(), t1 + \" + \" + t2); System.out.println(log); return t1 + t2 ; }); System.out.println(sum); //5 // 串行流三参 sum = Stream.of(1, 2, 3).reduce(4, (t1, t2) -> { String log = String.join(\" | \",\"中间参数\", Thread.currentThread().getName(), t1 + \" + \" + t2); System.out.println(log); return t1 + t2; }, (t1, t2) -> { System.out.println(\"执行了第三个参数\"); return t1 + t2 ; }); System.out.println(sum); // 3 输出结果为： 中间参数 | main | 4 + 2 中间参数 | ForkJoinPool.commonPool-worker-9 | 4 + 1 中间参数 | ForkJoinPool.commonPool-worker-2 | 4 + 3 第三个参数 | ForkJoinPool.commonPool-worker-2 | 6 + 7 第三个参数 | ForkJoinPool.commonPool-worker-2 | 5 + 1318 中间参数 | main | 4 + 1 中间参数 | main | 5 + 2 中间参数 | main | 7 + 310 通过上述输出结果可以看出，并行流中第二个参数使用初始值分别和流中每个元素相加，得出的结果再交给第三个参数进行合并，看起来怪怪的。 11 collect 收集 将结果收集为多种类型：常用的有 collect(Collectors.toList()) collect(Collectors.toSet()) collect(Collectors.toMap()) collect(Collectors.groupingBy())， 更多的查看java.util.stream.Collectors下提供的方法！ // collect(Collectors.toList()) 收集为list List nameList = userStream().map(User::getName).collect(Collectors.toList()); System.out.println(nameList); // [卡诺1, 卡诺2, 卡诺3, 卡诺4, 卡诺5] // collect(Collectors.toSet()) 搜集为set Set set = Arrays.asList(1, 2, 3, 1).stream().collect(Collectors.toSet()); System.out.println(set); // [1, 2, 3] // collect(Collectors.toMap()) 根据名称收集为map，如果key重复需要使用toMap的三参数，设置为覆盖 Map firstUserMap = userStream().limit(1).collect(Collectors.toMap(User::getName, Function.identity())); System.out.println(firstUserMap); // {卡诺1=User(name=卡诺1, age=11, gender=0)} // collect(Collectors.groupingBy()) 根据名称分组 Map> collect = userStream().limit(1).collect(Collectors.groupingBy(User::getName)); System.out.println(collect); // {卡诺1=[User(name=卡诺1, age=11, gender=0)]} 以上仅列出常见的Stream操作，Lambda中有特化的内置函数接口，Stream也有，比如：IntStream、LongStream等，使用流程和Stream一样，或增加一些常用的统计方法比如sum等。 12 parallelstream并行流 上面我们探讨的大都是串行流，而Java同样也为我们提供了更加快捷的并行处理方式，并行流就是将一块内容分成多块交由不同的线程处理，线程池由ForkJoinPool.commonPool()提供，底层使用Fork/Join框架实现，而串行流转化成并行流的方式也很简单，如下： Stream.of().parallel() 并行流的代码整体操作与串行流几乎无异，但是由于它使用的公共ForkJoinPool。所以尽可能避免操作阻塞、重量级的任务，否则会导致其他依赖并行流的部分变得缓慢。 3.4 总结 本章主要针对Stream进行讲解，并结合Lambda给出相关案例； Stream使用包括：创建流->中间操作->终端操作，其中中间操作可以包含多个； parallelstream并行流需要考虑线程安全的相关问题（死锁、事物等）所以它更适合没有线程安全问题的数据处理，stream则适合线程安全、阻塞、重量级任务的处理； 4 Files.lines使用注意事项 Files.lines()方法使用相关问题 4.1 使用try-with-resources 从path对应的文件中读取所有内容,并按行分割,返回一个Stream. 因为是流，使用完后必须得关闭流，否则会报/proc/stat: Too many open files 使用try-with-resources语句来保证stream的close方法被调用,从而关闭打开的文件: try(Stream stream = Files.lines(Paths.get(file))){ return stream.skip(start).limit(limit).collect(Collectors.toList()); } catch (IOException e){ logger.error(\"get content from{} error,{}\",file, e.getMessage()); } //等价于： Stream stream = Files.lines(Paths.get(file)); try { return stream.skip(start).limit(limit).collect(Collectors.toList()); } catch (IOException e){ logger.error(\"get content from{} error,{}\",file, e.getMessage()); } finally { stream.close(); } 5 spring xml bean的property的简写——p命令空间 对“setter方法注入”进行简化，替换，不再用， 而是在bean标签里 p命名空间使用前提，必须添加命名空间: Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 17:34:07 "}}